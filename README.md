# asmd23-public-03-LLM
## Task1 - Code Generation
This task involves evaluating the effects of different LLMs in generating solutions for last year's OOP exam, specifically the exam a01a available in the repository provided by the professor.
### ChatGPT
Respecting the exam assignment, ChatGPT was asked to implement the **TimeTableFactory** interface. The generated code is located in the **chatGPT** package and consists of two implementations of the provided interfaces: **TimeTableImpl** and **TimeTableFactoryImpl**. Two different prompting strategies were adopted:

**Zero-shot**: 
I asked ChatGPT to generate the TimeTableImpl and TimeTableFactoryImpl classes, passing it:
- the Pair class
- the TimeTable and TimeTableFactory interfaces.

The generated response was as follows:

    public class TimetableImpl implements Timetable {
      private final Map<Pair<String, String>, Integer> data;
      public TimetableImpl() {
          this.data = new HashMap<>();
      }
  
      public TimetableImpl(Map<Pair<String, String>, Integer> data) {
          this.data = new HashMap<>(data);
      }
  
      @Override
      public Timetable addHour(String activity, String day) {
          Map<Pair<String, String>, Integer> newData = new HashMap<>(data);
          Pair<String, String> key = new Pair<>(activity, day);
          newData.put(key, newData.getOrDefault(key, 0) + 1);
          return new TimetableImpl(newData);
      }
  
      @Override
      public Set<String> activities() {
          Set<String> activities = new HashSet<>();
          for (Pair<String, String> key : data.keySet()) {
              activities.add(key.get1());
          }
          return activities;
      }
  
      @Override
      public Set<String> days() {
          Set<String> days = new HashSet<>();
          for (Pair<String, String> key : data.keySet()) {
              days.add(key.get2());
          }
          return days;
      }
  
      @Override
      public int getSingleData(String activity, String day) {
          return data.getOrDefault(new Pair<>(activity, day), 0);
      }
  
      @Override
      public int sums(Set<String> activities, Set<String> days) {
          int sum = 0;
          for (Pair<String, String> key : data.keySet()) {
              if (activities.contains(key.get1()) && days.contains(key.get2())) {
                  sum += data.get(key);
              }
          }
          return sum;
      }
    }

    public class TimetableFactoryImpl implements TimetableFactory {
      
      public Timetable empty() { return new TimetableImpl();}
      
      @Override
      public Timetable single(String activity, String day) {
          return new TimetableImpl().addHour(activity, day);
      }
  
      @Override
      public Timetable join(Timetable table1, Timetable table2) {
          TimetableImpl result = new TimetableImpl();
          for (String activity : table1.activities()) {
              for (String day : table1.days()) {
                  result = (TimetableImpl) result.addHour(activity, day);
              }
          }
          for (String activity : table2.activities()) {
              for (String day : table2.days()) {
                  result = (TimetableImpl) result.addHour(activity, day);
              }
          }
          return result;
      }
  
      @Override
      public Timetable cut(Timetable table, BiFunction<String, String, Integer> bounds) {
          TimetableImpl result = new TimetableImpl();
          for (String activity : table.activities()) {
              for (String day : table.days()) {
                  int hours = table.getSingleData(activity, day);
                  int maxHours = bounds.apply(activity, day);
                  if (hours > maxHours) {
                      hours = maxHours;
                  }
                  for (int i = 0; i < hours; i++) {
                      result = (TimetableImpl) result.addHour(activity, day);
                  }
              }
          }
          return result;
      }
    }



This implementation, however, turned out to be incorrect, as the tests were not executed properly. Following this, I realized that a single interaction with ChatGPT is not sufficient to obtain an adequate solution, 
and that's why I decided to adopt another approach: **Few-shot**.

- **Few-shot**: I passed the error generated by the test to ChatGPT.

  The request was as follows:
    ```
  java.lang.AssertionError:
  Expected :0
  Actual   :1
    ```
  The generated response was as follows:
  ```
  public Timetable join(Timetable table1, Timetable table2) {
    TimeTableImpl result = new TimeTableImpl();
  
    // Uniamo le ore dalla prima tabella
    for (String activity : table1.activities()) {
      for (String day : table1.days()) {
        int hours = table1.getSingleData(activity, day);
        for (int i = 0; i < hours; i++) {
        result = (TimeTableImpl) result.addHour(activity, day);
        }
      }
    }
  
    // Uniamo le ore dalla seconda tabella
    for (String activity : table2.activities()) {
      for (String day : table2.days()) {
        int hours = table2.getSingleData(activity, day);
        for (int i = 0; i < hours; i++) {
          result = (TimeTableImpl) result.addHour(activity, day);
        }
      }
    }
  
    return result;
  }

However, subsequently, the test presented another error, requiring an additional interaction with ChatGPT.

The request was as follows:
```
java.lang.AssertionError: 
Expected :[act1, act2, act3]
Actual   :[]
```
The generated response was as follows:
```
public Timetable cut(Timetable table, BiFunction<String, String, Integer> bounds) {
        Map<Pair<String, String>, Integer> newData = new HashMap<>();
        Map<Pair<String, String>, Integer> oldData = ((TimetableImpl) table).getData();

        for (Map.Entry<Pair<String, String>, Integer> entry : oldData.entrySet()) {
            String activity = entry.getKey().get1();
            String day = entry.getKey().get2();
            int hours = entry.getValue();
            int maxHours = bounds.apply(activity, day);
            int newHours = Math.min(hours, maxHours);
            newData.put(new Pair<>(activity, day), newHours);
        }

        return new TimetableImpl(newData);
    }
```
The modification made resolved the error in extracting activities during the iteration of the data map. Therefore, by updating the **cut** method, the tests passed successfully.

**Considerations**


Passing the source code, namely the Pair class, the test class, and the interfaces, to ChatGPT and asking it to generate the said implementations, I noticed that the produced code did not satisfy the test. Therefore, a **one-shot** approach cannot guarantee a satisfactory result. In my opinion, ChatGPT performs best when queried frequently. Indeed, a **few-shot** approach ensured a result capable of passing the test and meeting the requirements.